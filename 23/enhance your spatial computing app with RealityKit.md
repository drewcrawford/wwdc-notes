Go beyond the window and learn how you can bring engaging and immersive 3D content to your apps with RealityKit. Discover how SwiftUI scenes work in tandem with RealityView and how you can embed your content into an entity hierarchy. We'll also explore how you can blend virtual content and the real world using anchors, bring particle effects into your apps, add video content, and create more immersive experiences with portals. 

[[Build spatial experiences with RealityKit]] - we learned about basic building blocks.  entities.  Components.  Systems.  Which act on both entities and components to add functionality.

# RealityView attachments
### MoonOrbit - 2:30
```swift
import SwiftUI
import RealityKit

struct MoonOrbit: View {
    var body: some View {
        RealityView { content, attachments in
            guard let earth = Entity(named: "Earth") else {
                return
            }
            content.add(earth)

            if let earthAttachment = attachments.entity(for: "earth_label") {
                earthAttachment.position = [0, -0.15, 0]
                earth.addChild(earthAttachment)
            }
        } attachments: {
            Text("Earth").tag("earth_label")
        }
    }
}
```

in the attachments viewbuilder closure, we can add swiftui views.  Added a text view to labelt he earth.  Also add a tag modifier so that we can later identify when  our view is added.  


We map views by label.  

[[Work with Reality Composer Pro content in Xcode]]


# Video playback
Useful way of adding text content and other ui elements to a scene.  we acn also add a video graph to make it more engaging.

video player component - new component type in RK.  Used for embedding video content isndie of a 3d scene.  Components define specific behavior taht you can attach to entities.  To play a video using player component.

1.  load file
2. avplayer
3. create a videoPlayerComponent
4. a rectangular mesh matching aspect radio is autogenerated.  
5. since RK is a 3d-framework, your video will be represented as a mesh.  Supports captions, etc.

[[Deliver video content for spatial experiences]]


### makeVideoEntity - 8:03
```swift
public func makeVideoEntity() -> Entity {
    let entity = Entity()

    let asset = AVURLAsset(url: Bundle.main.url(forResource: "tides_video",
                                                withExtension: "mp4")!)
    let playerItem = AVPlayerItem(asset: asset)

    let player = AVPlayer()
    entity.components[VideoPlayerComponent.self] = .init(avPlayer: player)

    entity.scale *= 0.4

    player.replaceCurrentItem(with: playerItem)
    player.play()

    return entity
}
```

by default, it's 1m tall?  so we scale?
### Passthrough tinting - 10:05
```swift
var videoPlayerComponent = VideoPlayerComponent(avPlayer: player)
    videoPlayerComponent.isPassthroughTintingEnabled = true

    entity.components[VideoPlayerComponent.self] = videoPlayerComponent
```

your passthrough content is adjusted to match colors in the video.  SAme treatment for movies/tv shows on this platform.  Set `.isPassthroughTingingEnabled = true`.

also subscribe to video player events to be mnotified when properties change, such as content type, viewing mode, video size, etc.

### VideoPlayerEvents - 10:40
```swift
content.subscribe(to: VideoPlayerEvents.VideoSizeDidChange.self,
                      on: entity) { event in
        // ...
    }
```

# Portals

Opening to a different world visible through surface.  Separate lighting, masked by portal's geometry.


1.  portal
2. particle effect for rim
3. anchoring used to place on wall.

Add an entity that has the world component.  Marks its entity tree as belonging toa  differentw orld.  Only visible through ?

Attach entities as children of the world entity.  here we add models to the sky, earth, and moon.  As well as image based light to define lighting inside the world.

A mesh will generate a circular plane to act as the surface.

To make the mesh appear, we assign a material?

portal component its target is the world. The portal now acts as a mask to reveal world content.

### Portal - 13:12
```swift
struct PortalView : View {
    var body: some View {
        RealityView { content in
            let world = makeWorld()
            let portal = makePortal(world: world)

            content.add(world)
            content.add(portal)
        }
    }
}

public func makeWorld() -> Entity {
    let world = Entity()
    world.components[WorldComponent.self] = .init()

    let environment = try! EnvironmentResource.load(named: "SolarSystem")
    world.components[ImageBasedLightComponent.self] = .init(source: .single(environment),
                                                            intensityExponent: 6)
    world.components[ImageBasedLightReceiverComponent.self] = .init(imageBasedLight: world)

    let earth = try! Entity.load(named: "Earth")
    let moon = try! Entity.load(named: "Moon")
    let sky = try! Entity.load(named: "OuterSpace")
    world.addChild(earth)
    world.addChild(moon)
    world.addChild(sky)

    return world
}

public func makePortal(world: Entity) -> Entity {
    let portal = Entity()

    portal.components[ModelComponent.self] = .init(mesh: .generatePlane(width: 1,
                                                                        height: 1,
                                                                        cornerRadius: 0.5),
                                                   materials: [PortalMaterial()])
    portal.components[PortalComponent.self] = .init(target: world)

    return portal
}
```

[[Explore rendering for spatial computing]]

Because they are children of the world, they're only visible through the portal.

To make a portal, we first need a mesh.  Create by creating model component.  To make it circular, we generate ap lane with equal dimensions and 0.5 radius.
# Particle emitters
### Adding particles around the portal - 15:50
```swift
public class ParticleTransitionSystem: System {
    private static let query = EntityQuery(where: .has(ParticleEmitterComponent.self))

    public func update(context: SceneUpdateContext) {
        let entities = context.scene.performQuery(Self.query)
        for entity in entities {
            updateParticles(entity: entity)
        }
    }
}

public func updateParticles(entity: Entity) {
    guard var particle = entity.components[ParticleEmitterComponent.self] else {
        return
    }

    let scale = max(entity.scale(relativeTo: nil).x, 0.3)

    let vortexStrength: Float = 2.0
    let lifeSpan: Float = 1.0
    particle.mainEmitter.vortexStrength = scale * vortexStrength
    particle.mainEmitter.lifeSpan = Double(scale * lifeSpan)

    entity.components[ParticleEmitterComponent.self] = particle
}
```

[[Build spatial experiences with RealityKit]] - custom systems

[[Meet Reality Composer Pro]] - particle emitter properties
# Anchors

Attach to the wall.  To dot his, we can use anchors.

* attach content to real environment
* `.continuous` or `.once`.  Continuous - anchor entity moves along with the anchor over time, such as when head moves.  Once - anchor entity will not move after being positioned once.
* Listen to `AnchoredStateChanged` events.
* Anchor transforms are not visible to app to preserve user privacy.
* Must use ARKit to get access.
[[Meet ARKit for spatial computing]]

### Anchoring the portal - 18:19
```swift
import SwiftUI
import RealityKit

struct PortalApp: App {

    @State private var immersionStyle: ImmersionStyle = .mixed

    var body: some SwiftUI.Scene {
        ImmersiveSpace {
            RealityView { content in
                let anchor = AnchorEntity(.plane(.vertical, classification: .wall,
                                                 minimumBounds: [1, 1]))
                content.add(anchor)

                anchor.addChild(makePortal())
            }
        }
        .immersionStyle(selection: $immersionStyle, in: .mixed)
    }
}
```
immersive spaces - [[Go beyond the window with SwiftUI]]

# Wrap up
* embed swiftui views inside of realitykit content
* enhance scenes with video, portals, and particles
* attach entities to real-world surfaces using anchors

[[Build spatial experiences with RealityKit]] - core RK concepts
[[Work with Reality Composer Pro content in Xcode]] - authoring tools
# Resources
* https://developer.apple.com/documentation/visionOS/diorama
