#widgetkit 

Widgets can appear 
* pages of home screen
* stacks
* today view
* macos notification center

# The basics
Widget extension contains swiftuI code to render visual appearance of the widget.
Make sure you've set up an extension already
[[Meet WidgetKit]]

Can specify which options appear in backside and are configureable.  These are rendered by the system.  *Parameters*.

Intents.  An ordered list of parameters.  Each parameter will show up as a row.

Once you define an intent, xcode generates the intent class containing a property for each parameter.  An instance of this class will be passed into the widget extension at runtime.
# Types of data entry
* string -> text field
* boolean -> switch
* numbers ->
	* for integers, number fields and steppers
	* decimals: number fields and sliders
* contact -> picker
* location -> picker
* enumerations.  static or dynamic.
* date components
* duration
* url
* measurement
* currency amount
* payment method

Can support multiple values.  ex, if the widget supporst a list of events from your calendar, can support selecting multiple calendars.

Intents now support fixed size arrays.  Useful if your widget supports a fixed number of items, prevents the user from adding more items.  Note, this appears to be a maximum size, not a minimum size or rust-fixed-array-size.

## demo
Switch from `StaticConfiguration` to `IntentConfiguration`.
Check "Intent is eligible for widgets" option.

## dynamic options and search
Widget configuration might vary by person and can't be specified in intent definition file.

Implement dynamic options.  "Options are provided dynamically" checkbox.
System should consult your app to retrieve the values.

1.  Visual appearance of parameter will change into a button that opens a modal list of options.
2.  2 methods are generated for you to implement
	1.  provide a list of possible options
	2.  default value

These methods are part of "Intent handler"
* protocol, generated by xcode
* implement in app, or Intents extension
* Provides data to the system while the user is configuring

Can either provide a flat list or sections.  If you use sections, your UI will be grouped by section.

To provide autocomplete results, check "Intent handler provides search results as the user types".  Also provide a prompt.

Then we give you a search term parameter.  Initially, this is called with `nil`, and as you type it's called again.

### demo
Default is used when widget is dragged onto home screen for the first time.

Need to switch `TimelineProvider` to `IntentTimelineProvider`.  This gives the methods an additional argument.


# Configuration experience
You can customize the title and the description by calling `.configurationDisplayName()` and `description`.
Style background and accent color to match your app's color scheme.

Add "named colors" to your asset catalog (for the widget extension).

Add "Global Accent Color Name" etc. to widget build settings (maybe in general panel?)

## parameter visibility
Consider a UI like "Mirror calendar" where if it's off, we display additional settings for "calendar".

Make "mirror calendar" a parent of "calendar".  "Show if parent" has exact value false.


# System intelligence

Not only can you add widgets to the home screen, you can stack multiple widgets together in one place.

Stacks -> system can automatically rotate widgets to the top of the stack to provide useful and timely information.

How do stacks behave intelligently?  How can I appear at the right time?

**provide timely, granceable information with obvious value to the user**

1.  User-behavior based.  We want to surface info the user looks for at a time.  ex., if someone frequently launches your weather app, the system can instead surface widgets with that info.
2.  Relevant information from your app.  ex., if a thunderstorm is happening, your widget can inform your system it has a highly-relevant update, and the system will consider surfacing.

How do you provide this info?

## user behavior
Intent donations.  These donations now surface your widget on top of the stack.[[Introduction to Siri Shortcuts - 18]]
[[Design for Intelligence Make Friends with The System]]

### demo
Idea here is to inform system when a user is checking a particular credit card in our app.  We donate this intent.

First, we need to check "eligible for siri suggestions".  That opens up the bottom section.  Want to match any widget with that card configured.  Add a "supported combinations" with the card parameter.

```swift
.onAppear {
	let intent = ViewRecentPUrchasesIntent()
	intent.card = Card(identifier: self.card.id.uuidString, display: self.card.name)
	
	let interaction = INInteraction(intent: intent, response: nil)
	interaction.donate { error in
		if let error = error {
			print(error.localizedDescription)
		}
	}
}
```

Note that in this case we configured "supported combinations" to be card (only).  So even if we provide category here, system will treat this as if it's only the card parmeter for scoring purposes.


### under the hood

Based on these donations, the system will recognize that the user typically does activity XYZ.  And will surface our widget as long as the app configured it to show the card.  Regardless of the category.

What if card + category is supported combination?  Now since category is part of combination, you're telling the system it's important.  Then at friday at noon, system will predict the intent.  

In short, supported combinations is the way to communicate to the system which parameter(s) are what the user is truly looking for.

### summarize
* set up configuration for your widget with an `INIntent`
* mark as eligible for siri suggestions
* configure supported combination for only the parameters that you want the system to predict
* donate the intent in your host app

## when you have important relevant info
You provide timeline entries.  

You can convey this information by supplying a timeline entry relevance object.

`TimelienEntryRelevance`
score of 0 or lower indicates your widget has no relevant information and should not be surfaced.

For event, we add future timeline updates with `nil`.  This tells the system to ignore this update for relevance purposes.

### summary
* donate INIntents that match your configuration intent
* provide TiemlineEntryRelevance when your widget has important information

