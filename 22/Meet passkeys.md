Next-generation authentication technology.

First, let's talk about pass*words*.  
* difficult to use correctly
* security vs convenience tradeoffs
* phishable and reusable.

Tradeoff between keeping accounts secure and designing a good experience.  In monterey, we announced developer preview of a solution: **Passkeys**.  

Now we're making them available.  Now is the time to adopt them.  Wtih passkeys, not only is a user experience better than a password, but also entire categoreis of security problems are not possible.

# Shiny demo
1.  username
2. password, 2nd step
3. SMS message
eventually, I'm signed in.

Add passkey => system sheet.  In just a few taps, my device has generated a unique, cryptographically-strong keypair and stored it in my iCloud keychain.

Going to sign up at the same signup form I used earlier.  Focus the username field like before, now that I have a passkey saved to my account, it shows up in the quicktype bar.  Tap it, and I'm signed in.  One step.

I didn't have to come up with a new password or try to satisfy any complexity requirement.  Each passkey is generated by the system and is guaranteed to be strong and only used for 1 account.  Only letting me use it in the correct app or website.

Passkeys work on the web too.  Just like on my phone, when I focus the username field, the passkye is already there and ready to use, thanks to iCloud keychain.  

Built on open standards.  Working with other platform vendors within the FIDO alliance to make sure compatible cross-platform and can work on as many devices as possible.

When I press sign-in, I get a sheet offering to let me use my phone.  Get a QR code.  Phone recognizes that this QR code is the one for the passkey.  My phone and the browser securely connect to each other.  Now I can continue, and I'm signed in.

Cross-platform signin experience is a first-class part of passkeys.

This is not just a QR code.  Behind the scenes, the devices performing a local key agreemnt, proving proximity, establishing an e2e communication channel.

Share account with two or more people.  Open up account details.  Now my partner has the passkey too.  And that's how easy it is to use passkeys.  (Maybe this requires airdrop?)

# Designing for passkeys
Replacements for passwords.  Faster to sign in with, easier to use, and more secure.

* Generic, user-visible term
* Common noun: "passkey"
	* lowercase
	* plurals
* SF symbols `person.key.badge` `person.key.badge.fill`
	* > on apple platforms

Username field is the centerpoint for most apps and websites.  Pretty much everyone knows how to use it, many apps and websites take advantage.

Now, a username field has another big feature.  Passkeys bring new paradigms.  Can now present passkeys using autofill as a first-class feature, letting you drop them right into your existing signin flow.  Interface looks familiar, etc.

## Additional UI options
wide range of additional UI options.

# Passkeys and autofill
* Built on WebAuthn
	* any standard implementation should work
* Public key cryptography
* Require backend adoption

## ASAuthorization API
* passkeys are part of ASAuthorization family
* supports many different credential types
* New flexible UI options

[[Introducing Password AutoFill for Apps - 17]]
[[What's new in Universal Links]]

```json
{
    "webcredentials": {
        "apps": [ "A1B2C3D4E5.com.example.Shiny" ]
    }
}
```

Make sure you're using the right textContentType

```swift
override func viewDidLoad() {
    super.viewDidLoad()
    //Additional setup…

    userNameField.textContentType = .username
}
```

```swift
// AutoFill-assisted passkey request

func signIn() {
    let challenge: Data = … // Fetched from server
    let provider =
        ASAuthorizationPlatformPublicKeyCredentialProvider(
            relyingPartyIdentifier: "example.com")
    let request =
        provider.createCredentialAssertionRequest(
            challenge: challenge)

    let controller =
        ASAuthorizationController(
            authorizationRequests: [request])
    controller.delegate = self
    controller.presentationContextProvider = self

    // Start the request
    controller.performAutoFillAssistedRequests()
}
```

Whiel this request is running, whenever a username field is fosuced, system will offer available passkeys in quicktype.  Make sure to od this early in lifetime before username is focused, as it takes some time.

**Nothing gets filled in the text field.**

```swift
// Completing a passkey sign in

func authorizationController(controller: ASAuthorizationController,
     didCompleteWithAuthorization authorization: ASAuthorization) {
    
    guard let passkeyAssertion = authorization.credential as?
        ASAuthorizationPlatformPublicKeyCredentialAssertion
    else { … }

    let signature = passkeyAssertion.signature
    let clientDataJSON = passkeyAssertion.rawClientDataJSON

    // Pass these values to your server, and complete the sign in
…
}
```

autofill-assisted requests are powerful.  wtih that small code change, you offer a lot of flexibility.  Primary case is to get quicktype bar.  This s what you should expect to happen most often.

Also allows passkey signin from nearby devices.  Tap key icon to list all available passkeys/passwords and get to the toption to signin for the nearby device.  Then perform cross-device passkey signin.  Nothing special to do to support tihs.

If they don't have passkeys get they can just use the login form like they used to.  If a password is selected, the crediential will still be filled in the textfields.  we designed this AIP to let you drop it into existing signin flows.

If someone has already updated to using passkey, decides to use a username anyway.  Insetead of using autofill suggestion, cancel the autofill request and use ASAuthorizationController to present a **modal** signin.  Still a single tap, same delegate etc.

```swift
// Modal passkey request

func signIn() {
    let challenge: Data = … // Fetched from server
    let provider =      
        ASAuthorizationPlatformPublicKeyCredentialProvider(
            relyingPartyIdentifier: "example.com")
    let request = 
        provider.createCredentialAssertionRequest(
            challenge: challenge)
    
    let controller = 
        ASAuthorizationController(
            authorizationRequests: [request])
    controller.delegate = self
    controller.presentationContextProvider = self

    // Start the request
    controller.performRequests()
}
```

Those are the only codechanges you need to support passkeys.

## web
Web also supports autofill-assisted and modal flows.  Standard webauthn.

Getting to all available passkeys and passwords, or using a psskey from a nearby device.  With very little code.

```html
<input type="text" id="username-field" autocomplete="username webauthn" >
```

both password and paskey suggestions with those autocomplete tags.


```js
// AutoFill-assisted WebAuthn request (JavaScript)

function signIn() {
    if (!PublicKeyCredential.isConditionalMediationAvailable ||
        !PublicKeyCredential.isConditionalMediationAvailable()) {
        // Browser doesn't support AutoFill-assisted requests.
        return;
    }

    const options = {
        "publicKey": {
            challenge: … // Fetched from server
        },
        mediation: "conditional"
    };

    navigator.credentials.get(options)
        .then(assertion => { 
            // Pass the assertion to your server.
        });
}
```
```swift
// Modal WebAuthn request (JavaScript)

function signIn() {
    var options = {
        "publicKey": {
            challenge: … // Fetched from server
        }
    };

    navigator.credentials.get(options)
        .then(function (assertion) { 
            // Pass the assertion to your server.
    });
}
```

If the promise resolves, you'll receive an assertion object to verify and complete the signin.  If someone manually enters the username, they should use the API to present amodal signin sheet.

* Indicates use of biometrics or device password
* Apple platforms always require UV when biometrics are available
* Always use `userVerification: "preferred"` (default value)
	* To avoid creating a bad experience.

* Make autofill requests early
* Modal requests require a user gesture
	* Once per pageload outside?  Some limitations?
	* autofill requires no gesture
* passkeys replace Safari's legacy platform authenticator

New platform credentials will be created as passkeys.

# Streamlining sign-in
additional options
## Use passkey allow lists
Possible there are passkeys for multiple accounts on device.  All available passkeys will be shown by default.  Restrict this by

```swift
// Modal request with allow list

func signIn(userName: String) {
    let challenge: Data = … // Fetched from server
    let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(
        relyingPartyIdentifier:"example.com")
    let request = provider.createCredentialAssertionRequest(
        challenge: challenge)

    let credentialIDs: [Data] = … // Fetched from server for provided userName
    request.allowedCredentials = credentialIDs.map(
        ASAuthorizationPlatformPublicKeyCredentialDescriptor.init(credentialID:))

    let controller = ASAuthorizationController(authorizationRequests: [request])
    controller.delegate = self
    controller.presentationContextProvider = self

    // Start the request
    controller.performRequests()
}
```

Credential ID is a unique identifier for a passkey.  Webauthn should have a way to look up credential IDs for a given username.

When makign modal requests, use allow list when you have additional context about which accuont a user is trying to sign in with.

## Silent fallback requests
If there are no passkeys saved?  Or your allowlist doesn't match?

By default, you get a QR code.  Provides most flexbility.  New option to prefer credentials that are immediately available and fallback silently if there aren't any.  Offer up existing credentials if you want such as passwords.

```swift
// Modal passkey request, silent fallback

func signIn() {
    let challenge: Data = … // Fetched from server
    let provider = ASAuthorizationPlatformPublicKeyCredentialProvider(
        relyingPartyIdentifier:"example.com")
    let request = provider.createCredentialAssertionRequest(
        challenge: challenge)

    let controller = ASAuthorizationController(authorizationRequests: [request])
    controller.delegate = self
    controller.presentationContextProvider = self

    // Start the request
    controller.performRequests(options: .preferImmediatelyAvailableCredentials)
}
```

`.preferImmediatelyAvailableCredentials`.  Will get error if not available.

```swift
// Handling a silent fallback
    
func authorizationController(controller: ASAuthorizationController, 
    didCompleteWithError error: Error) {
    
    guard let error = error as? ASAuthorizationError else { … }

    if error.code == .canceled {
        // Either the user canceled the sheet, or there were no credentials available.
        showSignInForm()
    }
}
```

What you do from here depends on context.  Ex, if you are using this option as a way to test for local credentials, this is where you trigger showing the form.

If there's at least one matching credential, the full sheet will be displayed regardless of options used.  

**Make sure you don't make sign in form unreachable.**  Ex, modal dismissed immediately and no way to recover because no local passkeys on device.

My device has 3 different credentials for different accounts.  Combined credential requests.  Or only 1 if that's present on device.


```swift
// Combined credential modal request

func signIn() {
    let challenge: Data = … // Fetched from server
    let passkeyProvider = ASAuthorizationPlatformPublicKeyCredentialProvider(
        relyingPartyIdentifier:"example.com")
    let passkeyRequest = passkeyProvider.createCredentialAssertionRequest(
        challenge: challenge)

    let passwordRequest = ASAuthorizationPasswordProvider().createRequest()
    let signInWithAppleRequest = ASAuthorizationAppleIDProvider().createRequest()

    let controller = ASAuthorizationController(
        authorizationRequests: [passkeyRequest, passwordRequest, signInWithAppleRequest])
    controller.delegate = self
    controller.presentationContextProvider = self

    // Start the request
    controller.performRequests()
}
```

MOdal sheet will offer whatever credentials are available.

Same delegate callback regardless of which type you use:
```swift
// Completing a combined credential request

func authorizationController(controller: ASAuthorizationController, 
     didCompleteWithAuthorization authorization: ASAuthorization) {

    switch authorization.credential {
    case let passkeyAssertion as ASAuthorizationPlatformPublicKeyCredentialAssertion:
        finishSignIn(with: passkeyAssertion)

    case let signInWithAppleCredential as ASAuthorizationAppleIDCredential:
        finishSignIn(with: signInWithAppleCredential)

    case let passwordCredential as ASPasswordCredential:
        finishSignIn(with: passwordCredential)

    default:
        // Handle other credential types
        break
    }
}
```


# How passkeys work
Generally, what happens is after you enter the password, it is hashed and salted, and sent to server (order unspecified)

Later if you can present the same value, you enter the account.  Server stores useful representation, desireable to attackers.

Passkeys work differently.  Public/private key.Generated by devices securely, etc.  Stays on your devices even when signing in.  server doesn't have it, etc.

passkeys on apple plastforms use ES256?  Only your private key can produce a valid solution.  Your device produces a solution.  Only sends solution back to server.  Private key stays secret ando nly on your devices.  Server validates the solution using public key.  If solution is valid, you're signed in.

Server can be sure you ahve the right private key without knowing what it is.  Since server doesn't know any private keys, less viable for attackers.

Customers never have to know or think about it.  

Secure, phishing-resistant manner.  

* Client
* authenticator

1.  Client shows QR code.  Contains URL that encodes a pair of single-use encryption keys
2. Authenticator produces bluetooth advertisement, contianing routing information and key input
	3. Out-of-band key agreement that the server can't see.  Server can't read anything.
	4. strong claim that the two devices are in physical proximity.  A QR code sent from an email or generated on a fake website won't work because a remote attacker won't be able to receive the bluetooth advertisement.
5. Two devices connect to a relay server
6. standard FIDO CTAP operation.  Protected by key earlier.
7. Performed by the device and the web browser.  Website is not involved at any point.  Cross-device, cross-platform.  Just works anywhere passkeys can be used.
# Multi-factor authentication
Factors.  Different factors protect against different attacks.  Combining factors provide better collective coverage.

| protects against | memorized password | PW manager | PW manager + SMS/TOTP | PassKey |
| ---------------- | ------------------ | ---------- | --------------------- | ------- |
| guessing         | no                 | yes        | yes                   | yes+    |
| credential reuse | no                 | yes        | yes                   | yes     |
| device theft     | yes                | maybe      | maybe                 | yes     |
| phishing         | no                 | maybe      | maybe                 | yes        |
| server leaks     | no                 | no         | no                    |    yes     |

adding passwords to other flows makes sense.  But a passkey alone protects against so much more that it doesn't need additional factors.

# next steps
* adopt webauthn on your server
* Update your apps and websites for passkeys
* Transition your users away from passwords


https://support.apple.com/en-us/HT213305
https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys
